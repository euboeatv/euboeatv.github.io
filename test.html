<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chalkida rescue ¬∑ glass + d3</title>

    <!-- leaflet & draw -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
    <!-- d3 -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <!-- google font inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

    <style>
        /* ----- GLASS REVAMP + ANIMATIONS ----- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', sans-serif;
        }

        :root {
            --c1: #FFCE1F;
            --c2: #BFFF1F;
            --c3: #50FF1F;
            --glass-bg: rgba(255, 255, 255, 0.25);
            --glass-border: rgba(255, 255, 255, 0.4);
            --glass-shadow: 0 20px 40px rgba(0, 0, 0, 0.1), 0 4px 12px rgba(0, 0, 0, 0.06);
            --blur: blur(12px);
        }

        body, html {
            height: 100%;
            width: 100%;
            overflow: hidden;
            background: #1e2f3a; /* deep fallback */
        }

        /* ---- MAP fullscreen ---- */
        #map {
            height: 100vh;
            width: 100vw;
            z-index: 1;
            transition: filter 0.3s ease;
        }

        /* ---- GLASS PANELS (animated) ---- */
        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: var(--blur);
            -webkit-backdrop-filter: var(--blur);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            box-shadow: var(--glass-shadow);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            animation: floatIn 0.5s ease-out;
        }

        .glass-panel:hover {
            transform: translateY(-4px);
            box-shadow: 0 24px 48px rgba(0, 0, 0, 0.15);
            border-color: rgba(255, 255, 255, 0.7);
        }

        @keyframes floatIn {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        /* header ‚Äì tight & centered */
        header {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            width: auto;
            min-width: 340px;
            max-width: 95%;
            padding: 8px 18px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 24px;
            z-index: 1000;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 60px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.1);
            animation: slideDown 0.4s ease;
        }

        @keyframes slideDown {
            0% { opacity: 0; transform: translate(-50%, -20px); }
            100% { opacity: 1; transform: translate(-50%, 0); }
        }

        .logo h1 {
            font-size: 1.3rem;
            font-weight: 800;
            background: linear-gradient(135deg, #FFCE1F, #BFFF1F);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -0.5px;
            white-space: nowrap;
        }

        /* button strip inside header */
        .controls {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }

        .ctrl-btn {
            background: rgba(255, 255, 255, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 8px 12px;
            border-radius: 40px;
            font-weight: 600;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #112121;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }

        .ctrl-btn:hover {
            background: var(--c3);
            transform: scale(1.05) translateY(-2px);
            border-color: var(--c1);
            box-shadow: 0 10px 18px rgba(80,255,31,0.3);
        }

        .ctrl-btn.special {
            background: var(--c1);
            color: #1e3a2a;
            font-weight: 700;
        }

        .ctrl-btn.special:hover {
            background: var(--c2);
        }

        /* pet & sighting buttons (emojis) */
        .pet-btn { background: #ffeaa0; }
        .sight-btn { background: #ffb3b3; }

        /* hide file input */
        #import-geojson { display: none; }

        /* ---- bottom panels (glass, animated) ---- */
        .bottom-panels {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            gap: 20px;
            justify-content: space-between;
            pointer-events: none;
            z-index: 1000;
        }

        .panel-left, .panel-right {
            pointer-events: auto;
            width: 280px;
            max-width: 35%;
            min-width: 240px;
            padding: 16px 14px;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(18px);
            border: 1px solid rgba(255, 255, 255, 0.35);
            border-radius: 32px;
            transition: all 0.3s ease;
            animation: slideUp 0.5s ease-out;
        }

        @keyframes slideUp {
            0% { opacity: 0; transform: translateY(40px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        .panel-left:hover, .panel-right:hover {
            width: 320px;
            background: rgba(255, 255, 255, 0.3);
        }

        .panel-title {
            font-weight: 700;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #1f4a4a;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            border-bottom: 2px dashed var(--c1);
            padding-bottom: 6px;
        }

        /* d3 chart container */
        #chartContainer {
            width: 100%;
            height: 140px;
        }

        svg {
            display: block;
            margin: 0 auto;
            border-radius: 20px;
        }

        /* geoJSON preview */
        #geojson-code {
            font-size: 0.6rem;
            white-space: pre-wrap;
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0,0,0,0.1);
            padding: 8px;
            border-radius: 16px;
            color: #102020;
            transition: opacity 0.2s;
        }

        /* gps active pulse */
        #gps-btn.active {
            background: var(--c3);
            animation: pulse 1.8s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(80, 255, 31, 0.6); }
            70% { box-shadow: 0 0 0 12px rgba(80, 255, 31, 0); }
            100% { box-shadow: 0 0 0 0 rgba(80, 255, 31, 0); }
        }

        /* popup images */
        .popup-img { width: 100%; border-radius: 12px; margin-top: 6px; }

        /* mobile adaptive */
        @media (max-width: 700px) {
            header { flex-direction: column; gap: 8px; width: 95%; border-radius: 30px; padding: 10px; }
            .controls { justify-content: center; }
            .bottom-panels { flex-direction: column; align-items: center; left: 10px; right: 10px; }
            .panel-left, .panel-right { width: 100%; max-width: 100%; }
        }
    </style>
</head>
<body>

    <!-- glass header -->
    <header class="glass-panel">
        <div class="logo"><h1>üöÅ ŒßŒëŒõŒöŒôŒîŒë¬∑RESCUE</h1></div>
        <div class="controls">
            <button class="ctrl-btn" id="gps-btn" title="Follow my location">üì° GPS</button>
            <button class="ctrl-btn pet-btn" id="addPetBtn" title="Add pet marker">üê∂ Pet</button>
            <button class="ctrl-btn sight-btn" id="addSightingBtn" title="Add sighting">üëÄ Sighting</button>
            <button class="ctrl-btn" onclick="startDrawPolyline()" title="Path / route">üìè Path</button>
            <button class="ctrl-btn" onclick="startDrawFreehand()" title="Freehand line">‚úèÔ∏è Free</button>
            <button class="ctrl-btn" onclick="startDrawRectangle()" title="Rectangle zone">‚ñ≠ Zone</button>
            <button class="ctrl-btn" onclick="clearAll()" title="Clear everything">üóëÔ∏è</button>
            <button class="ctrl-btn" onclick="exportGeoJSON()" title="Export GeoJSON">üíæ Save</button>
            <label for="import-geojson" class="ctrl-btn" title="Load GeoJSON">üìÇ Load</label>
            <input type="file" id="import-geojson" accept=".geojson,application/json">
        </div>
    </header>

    <!-- map -->
    <div id="map"></div>

    <!-- bottom glass panels: left chart, right geojson preview -->
    <div class="bottom-panels">
        <div class="panel-left glass-panel">
            <div class="panel-title">üìä field summary ¬∑ d3</div>
            <div id="chartContainer"></div>
            <div style="font-size:0.7rem; margin-top:8px; text-align:center; opacity:0.7;">pets ¬∑ sightings ¬∑ routes ¬∑ zones</div>
        </div>
        <div class="panel-right glass-panel">
            <div class="panel-title">üóÇÔ∏è live geojson</div>
            <pre id="geojson-code">// waiting for data...</pre>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

    <script>
        (function() {
            // ---- INIT MAP (centered on Chalkida) ----
            const map = L.map('map', { zoomControl: false }).setView([38.4636, 23.5955], 14);
            L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap, CartoDB'
            }).addTo(map);

            // Feature group for all drawings
            const drawnItems = new L.FeatureGroup().addTo(map);
            // GPS trail polyline
            const breadcrumbTrail = L.polyline([], { color: '#50FF1F', dashArray: '5, 8' }).addTo(map);
            let userMarker = null;
            let isTracking = false;

            // ---- custom icons for pet & sighting (divIcon with emoji) ----
            function createPetIcon() {
                return L.divIcon({
                    className: 'custom-pet-icon',
                    html: '<div style="background:#FFCE1F; width:32px; height:32px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:20px; border:3px solid white; box-shadow:0 4px 10px rgba(0,0,0,0.2);">üêæ</div>',
                    iconSize: [32, 32],
                    popupAnchor: [0, -16]
                });
            }
            function createSightingIcon() {
                return L.divIcon({
                    className: 'custom-sight-icon',
                    html: '<div style="background:#BFFF1F; width:32px; height:32px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:20px; border:3px solid white; box-shadow:0 4px 10px rgba(0,0,0,0.2);">üëÄ</div>',
                    iconSize: [32, 32],
                    popupAnchor: [0, -16]
                });
            }

            // ---- helper: file to base64 ----
            const toBase64 = file => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
            });

            // ---- generic marker adder for pet/sighting ----
            async function addCustomMarker(type) {
                const text = prompt(`Enter ${type} description / note:`);
                if (text === null || !text.trim()) return;

                let base64 = "";
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';
                input.onchange = async (event) => {
                    const file = event.target.files[0];
                    if (file) base64 = await toBase64(file);

                    // choose icon
                    const icon = (type === 'pet') ? createPetIcon() : createSightingIcon();
                    const latlng = map.getCenter(); // default to map center, but we want user click? better to use click location
                    // we'll use map click via a one-time handler
                    map.once('click', (e) => {
                        const marker = L.marker(e.latlng, { icon: icon });
                        const popupContent = `<b>${type} note</b><br>${text}${base64 ? '<br><img src="'+base64+'" class="popup-img">' : ''}`;
                        marker.bindPopup(popupContent);
                        marker.feature = {
                            type: "Feature",
                            properties: { 
                                description: text, 
                                type: 'marker', 
                                markerType: type,
                                image: base64 
                            },
                            geometry: { type: "Point", coordinates: [e.latlng.lng, e.latlng.lat] }
                        };
                        drawnItems.addLayer(marker);
                        updateLiveGeoJSON();
                        updateD3Chart();
                    });
                    alert(`Click on map to place ${type} marker`);
                };
                input.click();
            }

            // ---- draw control (only edit/remove) ----
            const drawControl = new L.Control.Draw({
                draw: false,
                edit: { featureGroup: drawnItems }
            });
            map.addControl(drawControl);

            // ---- custom freehand (from previous, kept) ----
            L.Draw.Freehand = L.Draw.Polyline.extend({
                initialize: function (map, options) {
                    L.Draw.Polyline.prototype.initialize.call(this, map, options);
                    this.type = 'freehand';
                },
                addHooks: function () {
                    L.Draw.Polyline.prototype.addHooks.call(this);
                    this._drawing = false;
                },
                _onMouseDown: function (e) {
                    if (this._clickHandled || this._touchHandled || this._disableMarkers) return;
                    this._drawing = true;
                    this._onClick(e);
                },
                _onMouseMove: function (e) {
                    if (this._drawing) this._onClick(e);
                    else L.Draw.Polyline.prototype._onMouseMove.call(this, e);
                },
                _onMouseUp: function (e) {
                    this._drawing = false;
                    if (this._poly.getLatLngs().length > 2) this._finishDrawing();
                }
            });

            // ---- draw starter functions (expose globally) ----
            window.startDrawPolyline = () => new L.Draw.Polyline(map, { shapeOptions: { color: '#3388ff' } }).enable();
            window.startDrawFreehand = () => new L.Draw.Freehand(map, { shapeOptions: { color: '#ff4444', weight: 3 } }).enable();
            window.startDrawRectangle = () => new L.Draw.Rectangle(map).enable();
            window.startDrawCircle = () => new L.Draw.Circle(map).enable();

            // ---- pet & sighting buttons ----
            document.getElementById('addPetBtn').addEventListener('click', () => addCustomMarker('pet'));
            document.getElementById('addSightingBtn').addEventListener('click', () => addCustomMarker('sighting'));

            // ---- GPS ----
            document.getElementById('gps-btn').addEventListener('click', () => {
                isTracking = !isTracking;
                const btn = document.getElementById('gps-btn');
                if (isTracking) {
                    btn.classList.add('active');
                    map.locate({ watch: true, enableHighAccuracy: true });
                } else {
                    btn.classList.remove('active');
                    map.stopLocate();
                }
            });

            map.on('locationfound', (e) => {
                if (!userMarker) {
                    userMarker = L.circleMarker(e.latlng, { radius: 8, color: '#fff', fillColor: '#3388ff', fillOpacity: 1, weight: 3 }).addTo(map);
                }
                userMarker.setLatLng(e.latlng);
                breadcrumbTrail.addLatLng(e.latlng);
                if (isTracking) map.panTo(e.latlng);
            });

            // ---- handle draw created (for lines, polygons etc) ----
            map.on(L.Draw.Event.CREATED, async (e) => {
                let layer = e.layer;
                let type = e.layerType;
                let isClosed = false;

                // for freehand/polyline check if closed -> polygon
                if (type === 'polyline' || type === 'freehand') {
                    const latlngs = layer.getLatLngs();
                    if (latlngs.length > 2) {
                        const first = map.latLngToLayerPoint(latlngs[0]);
                        const last = map.latLngToLayerPoint(latlngs[latlngs.length - 1]);
                        if (first.distanceTo(last) < 25) { // threshold
                            const polygonLayer = L.polygon(latlngs, layer.options);
                            layer = polygonLayer;
                            type = 'polygon';
                            isClosed = true;
                        }
                    }
                }

                // prompt description
                const desc = prompt(`Description for this ${type}:`);
                if (desc === null) return; // cancel

                let popupContent = `<b>${type}</b><br>${desc || '‚Äî'}`;
                layer.bindPopup(popupContent);
                layer.feature = {
                    type: "Feature",
                    properties: { description: desc, type: type },
                    geometry: layer.toGeoJSON().geometry
                };
                drawnItems.addLayer(layer);
                updateLiveGeoJSON();
                updateD3Chart();
            });

            // ---- update GeoJSON preview ----
            function updateLiveGeoJSON() {
                const geojson = drawnItems.toGeoJSON();
                document.getElementById('geojson-code').textContent = JSON.stringify(geojson, null, 2);
            }

            // ---- D3 chart ----
            function updateD3Chart() {
                const data = { pets: 0, sightings: 0, routes: 0, zones: 0 };
                drawnItems.eachLayer(layer => {
                    if (layer.feature && layer.feature.properties) {
                        const props = layer.feature.properties;
                        if (props.markerType === 'pet') data.pets++;
                        else if (props.markerType === 'sighting') data.sightings++;
                        else if (props.type === 'polyline' || props.type === 'freehand') data.routes++;
                        else if (props.type === 'polygon' || props.type === 'rectangle' || props.type === 'circle') data.zones++;
                        else if (layer instanceof L.Marker) { // generic marker? count as sighting? we'll keep as pet? we decide: if no markerType, maybe treat as sighting?
                            if (!props.markerType) data.sightings++; // fallback
                        }
                    } else if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) data.routes++;
                    else if (layer instanceof L.Polygon) data.zones++;
                    else if (layer instanceof L.Marker) data.sightings++;
                });

                // render small bar chart with d3
                const container = document.getElementById('chartContainer');
                container.innerHTML = ''; // clear
                const width = 240, height = 120;
                const svg = d3.select(container).append('svg')
                    .attr('width', width)
                    .attr('height', height)
                    .style('background', 'rgba(255,255,255,0.2)')
                    .style('border-radius', '20px');

                const x = d3.scaleBand()
                    .domain(['üêæ', 'üëÄ', 'üìè', 'üî≤'])
                    .range([20, width-20])
                    .padding(0.3);

                const y = d3.scaleLinear()
                    .domain([0, Math.max(1, data.pets, data.sightings, data.routes, data.zones)])
                    .range([height-30, 10]);

                const colors = ['#FFCE1F', '#BFFF1F', '#50FF1F', '#88ccff'];
                const values = [data.pets, data.sightings, data.routes, data.zones];

                svg.selectAll('rect')
                    .data(values)
                    .enter()
                    .append('rect')
                    .attr('x', (d,i) => x(['üêæ','üëÄ','üìè','üî≤'][i]))
                    .attr('y', d => y(d))
                    .attr('width', x.bandwidth())
                    .attr('height', d => height-30 - y(d))
                    .attr('fill', (d,i) => colors[i])
                    .attr('rx', 8)
                    .attr('ry', 8)
                    .attr('opacity', 0.9)
                    .on('mouseover', function() { d3.select(this).attr('opacity',1); })
                    .on('mouseout', function() { d3.select(this).attr('opacity',0.9); });

                svg.selectAll('text')
                    .data(values)
                    .enter()
                    .append('text')
                    .text(d => d)
                    .attr('x', (d,i) => x(['üêæ','üëÄ','üìè','üî≤'][i]) + x.bandwidth()/2)
                    .attr('y', d => y(d)-5)
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '10')
                    .attr('fill', '#1f3a3a');
            }

            // ---- export ----
            window.exportGeoJSON = () => {
                const data = drawnItems.toGeoJSON();
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: "application/json"});
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = `chalkida_${Date.now()}.geojson`;
                a.click();
            };

            // ---- clear ----
            window.clearAll = () => {
                if (confirm("Erase all drawings?")) {
                    drawnItems.clearLayers();
                    updateLiveGeoJSON();
                    updateD3Chart();
                }
            };

            // ---- import geojson ----
            document.getElementById('import-geojson').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = function(ev) {
                    try {
                        const geojson = JSON.parse(ev.target.result);
                        L.geoJSON(geojson, {
                            onEachFeature: (feature, layer) => {
                                if (feature.properties) {
                                    let content = '';
                                    if (feature.properties.markerType) {
                                        const mt = feature.properties.markerType;
                                        const icon = mt === 'pet' ? createPetIcon() : createSightingIcon();
                                        if (layer instanceof L.Marker) layer.setIcon(icon);
                                        content = `<b>${mt}</b><br>${feature.properties.description || ''}`;
                                    } else {
                                        const typ = feature.properties.type || feature.geometry.type;
                                        content = `<b>${typ}</b><br>${feature.properties.description || ''}`;
                                    }
                                    if (feature.properties.image) content += `<br><img src="${feature.properties.image}" class="popup-img">`;
                                    layer.bindPopup(content);
                                }
                                drawnItems.addLayer(layer);
                            }
                        });
                        map.fitBounds(drawnItems.getBounds());
                        updateLiveGeoJSON();
                        updateD3Chart();
                    } catch (err) { alert('Invalid GeoJSON'); }
                };
                reader.readAsText(file);
            });

            // hook for edit/delete events
            map.on(L.Draw.Event.EDITED, () => { updateLiveGeoJSON(); updateD3Chart(); });
            map.on(L.Draw.Event.DELETED, () => { updateLiveGeoJSON(); updateD3Chart(); });

            // initial chart
            updateD3Chart();

            // (optional service worker from original ‚Äì kept but simplified)
            if ('serviceWorker' in navigator) {
                // we skip registration to avoid blob url issues, but can be added if desired
            }
        })();
    </script>
</body>
</html>
